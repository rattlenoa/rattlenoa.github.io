---
layout:post
title: "자바공부"
---

산술 변환
이항 연산자는 두 피연산자의 타입이 일치해야 연산이 가능하므로,
피연사자의 타입이 서로 다르다면 연산 전에 형변환 연산자로 타입을
일치시켜야한다.

int타입과 float타입을 덧셈하는 경우, 형변환 연산자를 사용해서 피연산자의 타입을
둘 다 int 또는 float로 일치시켜야 한다.

int i = 10;
float f = 20.0f;

float result = f + (float)i; // 형변환으로 두 피연산자의 타입을 일치

대부분의 경우, 두 피연산자의 타입 중에서 더 큰타입으로 일치 시키는대
그 이유는 타입으로 형변환하면 원래의 값이 손실된 가능성이 있기 때문이다.
앞서 배운 것과 같이 작은 타입에서 큰 타입으로 형변환하는 경우,
자동적으로 형변환되므로 형변환 연산자를 생략할 수 있다.

float result = f + i ; // 큰 타입으로 형변환시, 형변환연산자 생략가능

연산 전에 피연산자 타입의 일치를 위해 자동 형변환 되는 것을 '산술 변환' 또는
'일반 산술 변환'이라 한다.

1.두 피연산자의 타입을 길게 일치시킨다.(보다 큰 타입으로 일치)
long + int -> long + long -> long
float + int -> float + float -> float
double + float -> double + double -> double

2.피연산자의 타입이 int보다 작은 타입이면 int로 변환한다.
byte + short -> int + int -> int
char + short -> int + int -> int

첫번째 규칙은 피연산자의 값손실을 최소화하기 위한것이고
두번째 규칙은 정수형의 기본 타입인 int가 가장 효율적으로 처리할 수 있는 타입이기때문에
표현범위가 좁아서 연산중에 오버플로우(overflow)가 발생할 가능성이 높기때문에 만들어졌다.

산술 변환이란? 연산 수행 직전에 발생하는 피연산자의 자동 형변환
1. 두 피연산자의 타입을 같게 일치시킨다(보다 큰 타입으로 일치).
2. 피연산자의 타입이 int보다 작은 타입이면 int로 변환된다.

증감 연산자 ++ --

대부분의 연산자는 피연산자의 값을 읽어서 연산에 사용할뿐,
피연산자의 타입이나 값을 변경시키지 않는다.

증가 연산자(++) 피연산자의 값을 1 증가시킨다.
감소 연산자(--) 피연산자의 값을 1 감소시킨다.

일반적으로 단항 연산자는 피연산자의 왼쪽에 위치하지만, 증가 연산자'++'와
감소 연산자'--'는 양쪽 모두 가능하다. 
피연산자의 왼쪽에 위치하면 '전위형(prefix)',오른쪽에 위치하면 '후위형(postfix)'이라고 한다.
 전위형 후위형 모두 피연산자의 값을 1증가 또는 감소 시키지만, 증감연산자가 수식이나
메서드 호출에 포함된 경우 전위형일 때와 후위형일 떄의 결과가 다르다.

타입/전위형  설명/값이 참조되기 전에 증가시킨다.    사용예/ j = ++i;
타입/후위형  설명/값이 참조된 후에 증가시킨다.       사용예/ j = i++;

증감연산자가 수식이나 메서드 호출에 포함되지 않고 독립적인 하나의 문장의 경우
전위형과 후위형의 차이가 없다.


public class operatorex1 {
	public static void main(String[] args) {
		int i=5;
		i++; 			// i=i+1;과 같은 의미이다. ++i;로 바꿔 써도 결과는 같다.
		System.out.println(i);
		
		i=5;			// 결과를 비교하기 이해 i값을 다시 5로 변경.
		++i;
		System.out.println(i);

	}

}



public class operatorex2 {
	public static void main(String[] args) {
		int i=5, j=0;
		
		j = i++;
		System.out.println("j=i++; 실행후, i=" + i + ", j="+ j);
		
		i=5;		// 결과를 비교하기 위해, i와 j의 값을 다시 5와 0으로 변경
		j=0;
		
		
		j = ++i;
		System.out.println("j=++i; 실행후, i=" + i + ", j="+ j);

	}

}

실행결과 i의 값은 두 경우 모두 1이 증가되어 6이 되지만 j는 그렇지 않다.
전위형은 변수(피연산자)값을 먼저 증가시킨 후에 변수의 값을 읽어오는 반면,
후위형은 변수의 값을 먼저 읽어온 후에 값을 증가시킨다.

(전위형) 

j = ++i;  // 전위형     ->     ++i; // 증가후에 
			j = i; // 참조하여 대입

(후위형)
j = i++; // 후위형       ->    j = i;  // 참조하여 대입 후에
			i++;  // 증가



public class operatorex3 {
	public static void main(String[] args) {
		int i=5, j=5;
		System.out.println(i++);
		System.out.println(++j);
		System.out.println("i = " + i + ", j = " +j);
		
	}

}

i는 값이 증가되기 전에 참조되므로 println()에게 i에 저장된 값 5를 넘겨주고 나서
i의 값이 증가하기 때문에 5가 출력되고, j는 j에 저장된 값을 증가시킨 후에 println()에게
값을 넘겨주므로 6이 출력된다.

실제 프로그래밍에서는 이런일은 잘없다.
하나의 식에서 증감연산자의 사용을 최소화하고, 식에 두 번 이상 포함된 변수에
증감연산자를 사용하느 것은 피해야 한다.
감소 연산자(--)는 피연산자의 값을 1 감소시킨다는 것만 빼면 증가 연산자와 동일하다.

부호 연산자 + -

부호 연산자'-'는 피연산자의 부호를 반대로 변경한 결과를 반환한다.
피연산자가 음수면 양수, 양수면 음수가 연산의 결과가 된다.
부호 연산자는 boolean형과 char형을 제외한 기본형에만 사용할 수 있다.


public class operatorex4 {
	public static void main(String[] args) {
		int i = -10;
		i = +i;
		System.out.println(i);
		
		i = -10;
		i = -i;
		System.out.println(i);
		

	}

}

 
