---

layout: post

title:  "2023년 5월 18일 프로그래밍 이론공부"

---

테스트 자동화 수행시 고려사항
모든 과정이 아닌 그때그때 맞는 적절한 도구를 선택

테스트 자동화 도구의 유형
정적 분석 도구
코딩 표준, 코딩 스타일, 코딩 복잡도, 남은 결함 등을
발견하기 위해 사용

테스트실행도구
스크립트 언어를 사용하여 테스트를 실행하는 방법

성능 테스트 도구
애플리케이션의 처리량, 응답 시간, 경과 시간, 자원 사용률
에 대해 가상의 사용자를 생성하고 테스트를 수행한다

테스트 통제 도구

테스트 하네스(Test Harness)도구구성요소

테스트 드라이버(Test Driver)
하위 -> 상위 모듈로 통합하면서 테스트하는 상향식 테스트에서 사용한다.

테스트 스텁(Test stub)
상위 -> 하위 모듈 방향으로 통합 테스트를 진행하는 하향식 테스트에서 사용한다.

테스트 슈트(Test Suites)
일정한 순서에 의하여 수행될 개별 테스트들의 집합, 또는 패키지이다.

테스트 케이스(Test Case)
요구에 맞게 개발되었는지 확인하기 위하여 테스트할 입력과 
예상 결과를 정의한 것

테스트 스크립트(Test Script)
테스트 케이스를 수행하여 그 결과를 보고할 목적으로
명령어 또는 이벤트 중심의 스크립트 언어로 작성한 파일로
수행경로에 영향을 미칠 논리 조건들을 포함하고 있다.

목 오브젝트(Mock Ob-ject) 조건부 입력하는것들을 수행하는 객체

통합 테스트

단위 테스트
소프트웨어 최소 기능 단위인 모듈, 컴포넌트를 테스트

통합 테스트(Integration Test)
각 모듈 간을 결합하여 시스템 완성시키는 과정에서
모듈 간 인터페이스 혹은 통합된 컴포넌트 간 상호작용 오류 및
결함을 찾아 해결하기 위한 테스트 기법이다.

비점진적 통합 방식(빅뱅 통합)
모든 모듈이 결합된 프로그램 전체를 대상으로 테스트한다.
규모가 작은 소프트웨어에 적합하다.

점진적 통합 방식(상향식/하향식)
단계적으로 통합하며 테스트한다.

통합 방식

하향식 통합방식
하위 컴포넌트 개발이 완료되지 않은 경우 스텁(Stub)을 사용하기도 한다.
우선 통합법, 깊이 우선 통합법, 넓이 우선 통합법등이 있다.

상향식 통합
Driver를 사용한다.

빅뱅(BigBang)통합
테스트를 위한 Driver와 Stub 없이 실제 모듈들로 테스트를 진행한다.

샌드위치 통합
상향식 하향식 장점을 이용한다.

결함 

결함 관리 도구
Mantis : 소프트웨어 설계 시 단위별 작업 내용을 기록할수 있어,
결함 및 이슈 관리, 추적을 지원하는 오픈소스 도구
Trac: 결함 추적 및 통합 관리 지원 
Bugzilla: 결함을 지속적으로 관리하고 심각도와 우선순위를
지정할 수 있는 오픈소스 도구
Redmine,JIRA,Test Collab

결함 관련 용어 

에러(Error)
소프트웨어 개발 또는 유지보수 수행 중에 발생한 부정확한 결과
개발자의 실수로 발생한 오타, 개발 명세서의 잘못된 이해,
서브루틴의 기능 오해 등이 있다.

오류(Fault)
잘못된 연산자가 사용된 경우

실패(Fault)
프로그램이 정상적으로 실행되지 못한 경우

결함(Defect)
버그, 에러, 오류,실패 등등 전체를 포괄하는 용어

결함 내성(Fault Tolerance)
시스템의 일부에서 결함 또는 고장이 발생해도
정상적 혹은 부분적으로 기능을 수행할 수 있는 내성을 의미한다.
-고장 허용성이라고도 한다.

애플리케이션 성능개선

성능 측정 지표

처리량(Throghput)
주어진 시간에 처리할 수 있는 프로세스 처리 수
응답 시간(Response Time)
데이터 입력 완료 시 부터 응답 출력이 개시될 때까지의 시간
경과 시간(Turnaround Time)
입력한 시점부터 그 결과의 출력이 완료할 때까지 걸리는 시간
자원 사용률(Resource Usage)
프로세스 처리 중 사용하는 CPU 사용량, 메모리 사용량, 네트워크 사용량

유형별 성능 분석 도구
성능/부하/스트레스(Performance/Load/Stress)점검도구
측정 지표인 처리량, 응답 시간, 경과 시간 등을 점검하기 위해
가상의 시스템 부하나 스트레스를 통해 성능을 분석하는 도구이다.

모니터링(Monitoring)도구
잘하고 있는지 확인하는도구 

애플리케이션 성능 저하 원인
 DB Lock
과도한 데이터 조회/업데이트/인덱스 생성시 발생한다.

불필요한  DB Fetch
필요한 데이터보다 많은 대량의 데이터 요청이 들어 올 경우 발생한다.

알고리즘 
주어진 과제를 해결하기 위한 방법과 절차를 의미한다.
알고리즘은 자연어, 의사코드(Pseudocode), 순서도,
프로그래밍 언어를 이용하여 표현 가능하다.

알고리즘 설계 기법

분할 정복법(Divide & Conquer)
제시된 문제를 분할이 불가할 때까지 나누고, 각 과제를 풀면서
다시 병합해 문제의 답을 얻는 Top-Down 방식이다.
1. 분할(Divide) : 정복이 필요한 과제를 분할이 가능한 부분까지
분할하고,
2. 정복(Conquer) : 1에서 분할된 하위 과제들을 모두 해결(정복)한다.
3. 결합(Combine) : 그리고 2에서 정복된 해답을 모두 취합(결합)한다.
예 퀵 정렬 알고리즘,병합(합병) 정렬 알고리즘

동적 계획법(Dynamic Program-ming)
-주어진 문제를 해결하기 위해 부분 문제에 대한 답을 계속적으로 
활용해 나가는 Bottom-Up 방식이다.
-1 부분 문제로 분리 2 가장 낮은 단계의 부분 문제 해답 계산
3 이 부분 문제의 해답을 이용해 상위 부분 문제를 해결
-이전 단계의 해답을 활용하기 위해 반드시 기억할 수 있는 
저장소가 필요 하기 때문에 속도는 빠르지만, 공간 복잡도가 커지는 단점이 있다.
예 플로이드 알고리즘, 피보나치 수열 알고리즘 

탐욕법(Greedy Method)
국소적인 관점에서 최적의 해결 방법을 구하는 기법으로
최적의 해결 방법을 구하지는 못하나 동적 계획법보다 효율적이라고
할 수 있다.
예 크루스칼 알고리즘, 다익스트라 알고리즘

퇴각 검색법(Back-tracking)
어떤 문제의 최적해를 구하기 위해 모든 가능성을 찾아가는 방법이다.
N-Queen 문제 해결 시에 응용된다.
(N&N 체스판에 배치하게하는 문제)
동적 계획법과 같이 기억할 저장소를 필요로 한다.

분기 한정법(Branch & Bound)
정해진 범위(Bound)를 벗어나는 값들은 가지치기(Branch)해가며
결과값을 추적해 나가는 방식이다.
예 최적 우선 탐색(Best First Search0 알고리즘 A*알고리즘

근사 해법(Approx-imation Algorithm)
복잡도가 매우 높은 문제에 대해 가장 근사치의 값을 구하는 기법이다.
예 근사 알고리즘

시간 복잡도에 따른 알고리즘
시간 복잡도는 알고리즘이 문제를 해결하기 위한 시간(연산)의 횟수를 말한다.

시간 복잡도 Big-O 표기법 

O(1)
상수 시간의 복잡도를 의미하며 입력값 n이 주어졌을 때,
문제를 해결하는데 오직 한 단계만 거친다(해시 함수).

O(log2n)
로그 시간의 복잡도를 의미하며 입력값 n이 주어졌을 때,
문제를 해결하는데 필요한 단계들이  연산마다 특정 요인에 의해
줄어든다(이진 탐색).

O(Nlog2n)
선형 로그 시간의 복잡도를 의미하며 문제 해결을 위한 단계 수는
nlog2n 번의 수행 시간을 갖는다(퀵 정렬, 병합(합병) 정렬).

O(n)
선형 시간의 복잡도를 의미하며 문제를 해결하기위한 단계의 수와
입력값이 n이 1:1 관계이다(순차탐색).


Mccabe 순환 복잡도(Cyclomatic)

순환 복잡도
-프로그램의 이해 난이도는 제어 흐름 난이도의
복잡도에 따라 결정되며, 복잡도를 싸이클로메틱
개수에 의해서 산정하는 방법이다.
-싸이클로메틱의 개수와 원시 프로그램 오류의 개수는 밀접한
관계가 있다.
-최대 10을 넘지 않도록 하며 넘으면 이를 분해하도록 한다.

복잡도 계산 방식
-복잡도 = 화살표 수 - 노드수 + 2(제어 흐름 그래프를 통해 파악)
-복잡도 = 영역 수(폐 구간)+ 1(제어 흐름 그래프를 통해 파악)
-복잡도 = 의사 결정수 + 조건 수 + 1(프로그램 코드상에서 파악,
제어 흐름도를 그리기 어려운 경우 활용한다.)

순환 복잡도 : V(G) = E - N+2 = 6 - 4 + 2 = 4
E : 화살표 수,N은 노드 수(점)

해싱 함수의 종류
제산 방법(Division Method)
나머지 연산자(%)를 사용하여 테이블 주소를 계산하는 방법이다.

중간 제곱 방법(Mid-Square Method)
레코드 키값을 제곱한 후에 결과값의 중간 부분에 있는 몇 비트를
선택하여 해시 테이블의 홈주소로 사용하는 방법이다.

중첩 방법(Folding Method,  폴딩)
해싱 함수 중 레코드키를 여러 부분으로 나누고, 나눈 부분의
각 숫자를 더하거나 XOR 한 값을 홈주소로 삼는 방법이다.

기수 변환 방법(Radix Conversion Method)
레코드 키를 구성하는 수들이 모든 키들 내에서 자리별로 어떤
분포인지를 조사하여 비교적 고른 분포를 나타내는 자릿수를
필요한 만큼 선택, 레코드의 홈주소로 사용하는 방법이다.

무작위 방법(Random Method)
난수를 발생시킨 후 난수를 이용해 각 키의 홈주소를 산출하는 방법이다.

계수 분석 방법(Digit Analysis Method)
레코드 키를 구성하는 수들이 모든 키들 내에서 자리별로 
어떤 분포인지를 조사하여 비교적 고른 분포를 나타내는 자릿수를
필요한 만큼 선택, 레코드의 홈주소로 사용하는 방법이다.

동의어(Synonym)
해싱에서 동일한 홈주소로 인하여 충돌이 일어난 레코드들의 집합이다.
