---
layout:post
title: "2023년 5월1일 프로그래밍 이론공부 "
---

Infix 표기를 Prefix로 바꾸기
Infix로 표기된 수식에서 연산자를 해당 피연산자 2개의
앞(왼쪽)에 오도록 이동하면 Prefix가 된다.

Postfix 표기를 Infix로 바꾸기
Postfix는 Infix 표기법에서 연산자를 해당 피연산자 2개의
뒤(오른쪽)로 이동한 것이므로 연산자를 다시 해당 피연산자 2개의
가운데로 옮기면 된다.


삽입 정렬

초기 상태:[8][5][6][2][4]

1회전 [8][5][6][2][4] -> [5][8][6][2][4]
두 번째 값 5를 첫 번째 값과 비교하여 첫 번째 자리에 삽입하고 8을 한칸 뒤로 이동시킨다.

2회전 [5][8][6][2][4] -> [5][6][8][2][4]
세 번째 값 6을 첫 번째, 두 번째 값과 비교하여 8자리에 삽입하고 9을 한칸 뒤로 이동시킨다.

3회전 [5][6][8][2][4] -> [2][5][6][8][4]
네 번째 값 2를 처음부터 비교하여 맨 처음에 삽입하고 나머지를 한 칸씩 뒤로 이동시킨다.

4회전 [2][5][6][8][4] -> [2][4][5][6][8]
다섯 번째 값 4를 처음부터 비교하여 5자리에 삽입하고 나머지를 한 칸씩 뒤로 이동시킨다.

버블 정렬

초기 상태:[8][5][6][2][4]


1회전 [8][5][6][2][4] -> [5][6][8][2][4]
        [5][6][2][8][4] -> [5][6][2][4][8]

2회전 [5][6][2][4][8] -> [5][2][6][4][8]
        [5][2][4][6][8]

3회전 [2][5][4][6][8] -> [2][4][5][6][8]

4회전 [2][4][5][6][8]

선택 정렬

초기 상태:[8][5][6][2][4]

1회전 [8][5][6][2][4] -> [5][8][6][2][4]
     ->[2][8][6][5][4] -> [2][8][6][5][4]

2회전 [2][6][8][5][4] -> [2][5][8][6][4]
     ->[2][4][8][6][5]

3회전 [2][4][6][8][5] -> [2][4][5][8][6]
     ->[2][4][5][6][8]


2-Way 합병 정렬(Merge Sort)

71, 2, 38, 5, 7, 61, 11, 26, 53, 42를 2-Way 합병정렬로 정렬하시오.

1회전: 2개씩 묶은 후 각각의 묶음 안에서 정렬합니다.
(71,2) (38,5) (7,61) (11,26) (53,42)
                  ▼
(2,71) (5,38) (7,61) (11,26) (42,53)

2회전: 묶여진 묶음을 2개씩 묶은 후 각각의 묶음 안에서 정렬합니다.
((2, 71) (5,38)) (7, 61) (11, 26) (42, 53)
                   ▼
(2, 5, 38, 71) (7,11, 26, 61) (42,53)

3회전: 묶여진 묶음을 2개씩 묶은 후 각각의 묶음 안에서 정렬합니다.
(2, 5, 38, 71) (7, 11, 26, 61) (42, 53)
                   ▼
(2, 5, 7, 11, 26, 38, 61, 71) (42, 53)

4회전: 묶여진 묶음 2개를 하나로 묶은 후 정렬합니다.
((2, 5, 7, 11, 26, 38, 61, 71) (42, 53))
                   ▼
2, 5, 7, 11, 26, 38, ,42, 53, 61, 71 

이분 검색(이진 검색)
-제어 검색의 일종인 이분 검색은 반드시 순서화된 파일이어야 검색할 수 있다.
-탐색 효율이 좋고 탐색 시간이 적게 소요된다.
-전체 파일을 두 개의 서브 파일로 분리해 가면서 Key레코드를 검색하기 때문에 
검색회수를 거듭할 때마다 검색 대상이 되는 데이터의 수가 절반으로 줄어든다.
-찾고자 하는 Key 값을 파일의 중간 레코드 Key 값과 비교하면서 검색한다.
-중간 레코드 번호(M) : F+L분의 2 (단, F: 첫 번째 레코드 번호, L: 마지막 레코드 번호)

해싱(Hashing)
-Hash Table이라는 기억공간을 할당하고, 해시 함수 (Hash Function)를 이용하여 
레코드 키에 대한 Hash Table 내의 Home Address를 계산한 후 주어진 레코드를 
해당 기억장소에 저장하거나 검색 작업을 수행하는 방식이다.
-DAM(직접접근방법)파일을 구성할 때 해싱이 사용되며, 접근 속도는 빠르지만 기억공간이 많이 요구된다.
-여러가지 검색 방식 중 검색 속도가 가장 빠르다
-삽입, 삭제 작업의 빈도가 많을 때 유리한 방식이다.
-키-주소 변환 방법이라고도 한다.

해시 테이블(Hash Table)
-레코드를 1개 이상 보관할 수 있는 Home Bucket들로 구성한 기억공간으로,
보조기억장치에 구성할 수도 있고 주기억장치에 구성할 수도 있다.

버킷(Bucket) 
하나의 주소를 갖는 파일의 한 구역을 의미하며, 버킷의 크기는 같은 주소에 포함될 수 있는 레코드 수를 의미함

슬롯(Slot)
1 개의 레코드를 저장할 수 있는 공간으로 n개의 슬롯이 모여 하나의 버킷을 형성함

Collision(충돌 현상)
서로 다른 2개 이상의 레코드가 같은 주소를 갖는 현상

Synonym
같은 Home Address를 갖는 레코드들의 집합

Overflow
- 계산된 Home Address의 Bucket 내에 저장할 기억공간이 없는 상태
- Bucket을 구성하는 Slot이 여러 개일 때는 Collision은 발생해도 Overflow는 발생하지 않을 수 있음

순차 파일(Sequential File) = 순서 파일
-입력되는 데이터들을 논리적인 순서에 따라 물리적 연속 공간에 순차적으로 기록하는 방식이다.
-급여 관리 등과 같이 변동 사항이 크지 않고 기간별로 일괄 처리를 주로 하는 경우에 적합하다.
-주로 순차 접근이 가능한 자기 테이프에서 사용된다.

순차 파일의 장점
-기록 밀도가 높아 기억공간을 효율적으로 사용할 수있다.
-레코드가 키 순서대로 편성되어 취급이 용이하다.
-매체 변환이 쉬워 어떠한 매체에도 적용할 수 있다.
-레코드를 기록할 때 사용한 키 순서대로 레코드를 처리하는 경우, 다른 편성법보다 퍼리 속도가 빠르다.

순차 파일의 단점
-파일에 새로운 레코드를 삽입, 삭제, 수정하는 경우 파일 전체를 복사해야 하므로 시간이 많이 소요된다.
-데이터 검색 시 처음부터 순차적으로 하기 때문에 검색 효율이 낮다.

색인 순차 파일(Indexed Sequential File)
-순차 처리와 랜덤 처리가 모두 가능하도록 레코드들을 키 값 순으로 정렬(Sort)시켜 기록하고, 레코드의 
키 항목만을 모은 색인을 구성하여 편성하는 방식이다.
-색인을 이용한 순차적인 접근 방법을 제공하여 ISAM(Index Sequential Access Method)이라고도 한다.
-레코드를 참조할 때는 색인을 탐색한 후 색인이 가리키는 포인터(주소)를 사용하여 직접 참조할 수 있다.
-일반적으로 자기 디스크에 많이 사용되며, 자기 테이프에서는 사용할 수 없다.

색인 순차 파일의 구성
-기본 구역(Prime Area): 실제 레코드들을 기록하는 부분으로, 각 레코드는 키 값 순으로 저장
-색인 구역(Index Area): 기본 구역에 있는 레코드들의 위치를 찾아가는 색인이 기록되는 부분으로, 트랙 색인 구역,
실린더 색인 구역, 미스터 색인 구역으로 구분할 수 있음
-오버플로 구역(Overflow Area): 기본 구역에 빈 공간이 없어서 새로운 레코드의 삽입이 불가능할 때를 대비하여 
예비적으로 확보해 둔 부분

실린더 오버플로 구역(Cylinder Overflow Area)
각 실린더마다 만들어지는 오버플로 구역으로, 해당 실린더의 기본 구역에서 오버플로된 데이터를 기록함

독립 오버플로 구역(Independent Overflow Area)
실린더 오버플로 구역에 더 이상 오버플로 된 데이터를 기록할 수 없을 때 사용할 수 있는 예비 공간으로,
실린더 오버플로 구역과는 별도로 만들어짐

색인 순차 파일의 장점
-순차 처리와 랜덤 처리가 모두 가능하므로, 목적에 따라 융통성 있게 처리할 수 있다.
-효율적인 검색이 가능하고 레코드의 삽입, 삭제, 갱신이 용이하다.

색인 순차 파일의 단점
-색인 구역과 오버플로우 구역을 구성하기 위한 추가 기억 공간이 필요하다.
-파일이 정렬되어 있어야 하므로 추가, 삭제가 많으면 효율이 떨어진다.
-색인을 이용한 액세스를 하기 때문에 액세스 시간이 랜덤 편성 파일보다 느리다.


