---

layout: post

title:  "자바공부"

---
public class castingex4 {
	public static void main(String[] args) {
		int i = 91234567;    // 8자리의 10진수
		float f = (float)i; // int를 float로 형변환
		int  i2 = (int)f;   // float를 다시 int로 형변환
		
		double d = (double)i; // int를 double로 형변환
		int   i3 = (int)d;    // double을 다시 int로 형변환
		
		float f2 = 1.666f;
		int   i4 = (int)f2;
		
		System.out.printf("i=%d\n", i);
		System.out.printf("f=%f i2=%d\n", f, i2);
		System.out.printf("d=%f i3=%d\n", d, i3);
		System.out.printf("(int)%f=%d\n", f2, i4);
		


	}

}


float f = 1234; 
byte b = 1000;  //에러  byte의 범위(-128~127)를 넘는 값을 저장.
char ch = (char)1000; // 명시적 형변환. 에러가 발생하지 않는다.

int i = 3;
double d = 1.0 + i ; // double  d = 1.0 + (double)i;에서 형변환이 생략됨

double d = 1.0 + i;
->double d = 1.0 + (double)i; 
->double d = 1.0 + (double)3; // 3을 double타입으로 형변환하면 3.0이 된다.
->double d = 1.0 + 3.0;         // double과 double의 덧셈결과 타입은 double.
->double d = 4.0;                // double + double = double

자동 형변환의 규칙

기존의 값을 최대한 보존할 수 있는 타입으로 자동 형변환한다.
 
1.boolean을 제외한 나머지 7개의 기본형은 서로 형변환이 가능하다.
2.기본형과 참조형은 서로 형변환할 수 없다.
3.서로 다른 타입의 변수간의 연산은 형변환을 하는 것이 원칙이지만,
  값의 범위가 작은 타입에서 큰 타입으로의 형변환은 생략할 수 있다.

연산자

연산자(operator) 연산을 수행하는 기호(+,-,*,/등)
피연산자(operand) 연산자의 작업 대상(변수, 상수, 리터럴, 수식)

산술 연산자 + - * / % << >>   사칙 연산(+,-,*,/)과 나머지 연산(%)
비교 연산자 > < >= <= == !=  크과 작음과 같고 다름을 비교
논리 연산자 && || ! & | ^ ~ '그리고(AND)'와 '또는(OR)'으로 조건을 연결
대입 연산자       =             우변의 값을 좌변에 저장
     기타     (type) ?: instanceof 형변환 연산자, 삼항 연산자, instanceof연산자

(식) -x + 3

단항 연산자가 이항 연산자보다 우선순위가 높다.
그래서 x의 부호를 바꾼 다음 덧셈이 수행된다.
여기서 '-'는 뺄셈 연산자가 아니라 부호 연산자이다.

(식) x + 3 * y

곱셉과 나눗셈이 덧셈과 뺄셈보다 우선순위가 높다
그래서 '3 * y'가 먼저 계산된다.

(식) x + 3 > y - 2
비교 연산자(>)보다 산술 연산자 '+'와 '-'가 먼저 수행된다.
그래서 'x+3'과 'y-2'가 먼저 계산된 다음에 '>'가 수행된다.

(식) x > 3 && x < 5 
논리 연산자 '&&'보다 비교 연산자가 먼저 수행된다.
그래서'x > 3'와 'x < 5'가 먼저 계산된 다음에 '&&'가 수행된다.
식의 의미는 'x가 3보다 크고 5보다 작다'이다.

(식) result = x + y * 3;
대입 연산자는 연산자 중에서 제일 우선순위가 낮다.
그래서 우변의 최종 연산결과가 변수 result에 저장된다.

(식) x << 2 + 1
쉬프트 연산자(<)는 덧셈 연산자보다 우선순위가 낮다.
그래서 왼쪽의 식은 'x << (2+1)'과 같다.

(식) data & 0xFF == 0
비트 연산자(&)는 비교 연산자(==)보다 우선순위가 낮으므로 비교연산후에
비트연산이 수행된다. 그래서 왼쪽의 식은 'data & (0xFF == 0)'과 같다.

(식) x < -1 || x > 3 && x < 5
논리 연산자 중에서 AND를 의미하는 '&'와 '&&'가 OR를 의미하는 '|'와 '||'보다
우선순위가 높다. 이처럼 수식에 AND와 OR가 함께 사용되는 경우는
다음과 같이 괄호를 사용해서 우선순위를 명확히 하는 것이 좋다.
x < -1 || ( x > 3 && x <5)


하나의 식에 같은 우선순위의 연산자들이 여러 개 있는 경우,
규칙대로 연산하는것을 '연산자의 결합규칙'이라고 한다.

대부분 왼쪽에서 오른쪽의 순서로 연산을 수행한다.
단항 연산자와 대입 연산자만 그 반대로, 오른쪽에서 왼쪽의 순서로, 연산을 수행한다.

1. 산술 > 비교 > 논리 > 대입. 대입은 제일 마지막에 수행된다.
2. 단항(1) > 이항(2) > 삼항(3). 단항 연산자의 우선순위가 이항 연산자보다 높다.
3. 단항 연산자와 대입 연산자를 제외한 모든 연산의 진행방향은 왼쪽에서 오른쪽이다.


   
